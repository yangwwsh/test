<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="apigw_apirequestrouting_collection" xml:lang="en-us">
<title>Collection routing<ph rev="rev760"/></title>
<shortdesc>The <ph conref="apigw_conref.dita#common/apigw"/> determines the API
collection to route the request to by matching the request URL against the routing prefix of each
API collection. The collection routing follows certain rules, you must take the rules into
consideration when you design routing prefixes for your API collections. </shortdesc>
<conbody>
<p>For each API collection, the <ph conref="apigw_conref.dita#common/apigw"/> uses the
routing prefix of the collection to form a complete URI as follows and accepts only the incoming
requests with this URI.</p>
<codeblock>&lt;routing prefix>&lt;base path>&lt;operation path></codeblock>
<dl>
<dlentry>
<dt>Routing prefix</dt>
<dd>The <ph conref="apigw_conref.dita#common/apigw"/> supports the following types of
routing prefixes: <dl>
<dlentry>
<dt>URI</dt>
<dd>When the routing prefix type is URI, the routing prefix must begin but not end with slash
(<codeph>/</codeph>). </dd>
</dlentry>
<dlentry>
<dt>Host name</dt>
<dd>When the routing prefix type is host name, the prefix must not start or end with period
(<codeph>.</codeph>). You need to specify only the first part of the host name (with domain name
excluded); however, the request must use the complete URL with domain name included.</dd>
</dlentry>
</dl>You can use routing prefixes to organize your APIs into collections and subcollections. For
example, if you have a collection of APIs serving for a certain purpose such as human resource, and
the APIs are to be used by two segments of your organization, you might create two API collections
with the organization name, purpose name, and segment name in the routing prefix. <p>If the
organization name is <codeph>myorg</codeph>, the APIs serve for purpose <codeph>hr</codeph>, and the
two segments under the organization is <codeph>section1</codeph> and <codeph>section2</codeph>:<ul>
<li>When the routing prefix type is URI, the resulting routing prefixes are
<codeph>/myorg/hr/section1</codeph> and <codeph>/myorg/hr/section2</codeph>.</li>
<li>When the routing prefix type is host name, the resulting routing prefixes are
<codeph>section1.hr.myorg</codeph> and <codeph>section2.hr.myorg</codeph>.</li>
</ul></p><p>The default routing prefix is slash (<codeph>/</codeph>) when the type is URI and blank
when the type is host name. An API collection becomes the default collection in the <ph
conref="apigw_conref.dita#common/apigw"/> when the collection has a default routing
prefix. The <ph conref="apigw_conref.dita#common/apigw"/> routes a request to the
default collection when other collections do not match. An <ph
conref="apigw_conref.dita#common/apigw"/> can have only one default collection;
therefore, regardless of the prefix type, only one API collection can be configured with the default
routing prefix.</p></dd>
<dd>You can assign multiple routing prefixes to an API collection. For example, you might have a
collection of APIs that are already published for the organization. However, cases such as
rebranding of the organization might cause that you need to use this same set of APIs through a
different URL. In such cases, you can use two different routing prefixes for the API collection
during the transition from the old organization to the new organization.</dd>
</dlentry>
<dlentry>
<dt>Base path</dt>
<dd>Base path on which the API is served. A base path must begin but not end with slash
(<codeph>/</codeph>). </dd>
</dlentry>
<dlentry>
<dt>Operation path</dt>
<dd>Relative path to the base path where the operations are available. An operation path must begin
but not end with slash (<codeph>/</codeph>). </dd>
</dlentry>
</dl>
<p>When an <ph conref="apigw_conref.dita#common/apigw"/> receives a request, the <ph
conref="apigw_conref.dita#common/apigw"/> determines the API collection to route the
request to according to the following rules in sequence:<ul>
<li>Rule 1: Match the URI-prefixed collections first and route to the collection whose routing
prefix matches the most segments of the request URL.</li>
<li>Rule 2: When no collections are matched according to Rule 1, match the hostname-prefixed
collections and route to the collection with the longest matched length of routing prefix.</li>
<li>Rule 3: When no collections are matched according to Rule 1 and 2, route to the URI-prefixed
collection whose routing prefix is slash (<codeph>/</codeph>).</li>
<li>Rule 4: When no collections are matched according to Rule 1, 2, and 3, route to the
hostname-prefixed collection whose routing prefix is blank.</li>
</ul></p>
<p>The following table uses an example <ph conref="apigw_conref.dita#common/apigw"/>
with seven API collections to explain the collection routing rules. <table frame="all" rowsep="1"
colsep="1" id="table_yn3_tw1_gy">
<title>API collection routing example</title>
<tgroup cols="4">
<colspec colname="newCol1" colnum="1" colwidth="1*"/>
<colspec colname="c1" colnum="2" colwidth="1.0*"/>
<colspec colname="newCol3" colnum="3" colwidth="1*"/>
<colspec colname="c2" colnum="4" colwidth="1.0*"/>
<thead>
<row>
<entry>API collection name</entry>
<entry>Routing prefix type</entry>
<entry>Routing prefix</entry>
<entry>Base path</entry>
</row>
</thead>
<tbody>
<row>
<entry>A</entry>
<entry>URI</entry>
<entry><codeph>/pet/cat</codeph></entry>
<entry><codeph>/api</codeph></entry>
</row>
<row>
<entry>B</entry>
<entry>URI</entry>
<entry><codeph>/pet/dog</codeph></entry>
<entry><codeph>/api</codeph></entry>
</row>
<row>
<entry>C</entry>
<entry>URI</entry>
<entry><codeph>/pet</codeph></entry>
<entry><codeph>/cat</codeph></entry>
</row>
<row>
<entry>D</entry>
<entry>URI</entry>
<entry><codeph>/pet2</codeph></entry>
<entry><codeph>/cat</codeph></entry>
</row>
<row>
<entry>E</entry>
<entry>URI</entry>
<entry><codeph>/</codeph></entry>
<entry><codeph>/xyz </codeph></entry>
</row>
<row>
<entry>F</entry>
<entry>Host name</entry>
<entry><codeph>pet</codeph></entry>
<entry><codeph>/cat</codeph></entry>
</row>
<row>
<entry>G</entry>
<entry>Host name</entry>
<entry><codeph>pet2</codeph></entry>
<entry><codeph>/cat</codeph></entry>
</row>
</tbody>
</tgroup>
</table></p>
<ul>
<li>According to Rule 1:<ul>
<li>When the <ph conref="apigw_conref.dita#common/apigw"/> receives a request with a URL
of <codeph>http://&lt;host>/pet2/cat/api</codeph>, the request is routed to collection D because
only the prefix of D matches a complete section of the request URL.</li>
<li>When the <ph conref="apigw_conref.dita#common/apigw"/> receives a request with a URL
of <codeph>https://&lt;host>/pet/cat/api/pets</codeph>, although both A and C are matched, the
request is routed to collection A because the routing prefix of collection A matches more segments
of the request URL.</li>
<li>When the <ph conref="apigw_conref.dita#common/apigw"/> receives a request with a URL
of <codeph>http://pet2.&lt;subdomain>/pet2/cat/api</codeph>, although both D and G are matched, the
request is routed to collection D because the URI-prefixed collection takes higher priority.</li>
</ul></li>
<li>According to Rule 2, when the <ph conref="apigw_conref.dita#common/apigw"/> receives
a request with a URL of <codeph>http://pet20.&lt;subdomain>/cat/api</codeph>, the request is routed
to collection G because the matched string length of G is longer than F.</li>
<li>According to Rule 3, when the <ph conref="apigw_conref.dita#common/apigw"/> receives
a request with a URL of <codeph>https://&lt;host>/food/...</codeph>, the request is routed to
collection E because no collections are matched according to Rule 1 and 2.</li>
</ul>
</conbody>
<related-links>
<link href="apigw_configuringapicollection.dita"/>
</related-links>
</concept>
